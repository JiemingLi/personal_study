# 主从模式

MysQL主从模式是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL默认采用异
步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，从节点可以复制主数据库中的所有数据库，或
者特定的数据库，或者特定的表。

![img](https://blog.rubinchu.com/wp-content/uploads/2021/10/2-9.png)



主从复制整体分为以下三个步骤：

- 主库将数据库的变更操作记录到Binlog日志文件中
- 从库读取主库中的Binlog日志文件信息写入到从库的Relay Log中继日志中
- 从库读取中继日志信息在从库中进行Replay,更新从库数据信息

在上述三个过程涉及了Master的BinlogDump Thread和Slave的I/O Thread、SQL Thread，它们的作用如下：

- Master服务器对数据库更改操作记录在Binlog中，BinlogDump Thread接到写入请求后，读取Binlog信息推送给Slave的I/O Thread。
- Slave的I/O Thread将读取到的Binlog信息写入到本地Relay Log中。
- Slave的SQL Thread检测到Relay Log的变更请求，解析relay log中内容在从库上执行

上述过程都是**异步操作**，俗称**异步复制**，**存在数据延迟现象**。

![img](https://blog.rubinchu.com/wp-content/uploads/2021/10/3-7-1024x444.png)

主从复制带来的问题

- 在数据发送之后，主库宕机后，数据可能丢失。
- 从库只有一个SQL Thread，主库写压力大，复制很可能延时

解决办法

- 半同步复制（解决数据丢失的问题）
- 并行复制（解决从库复制延迟问题）

## 半同步复制

为了提升数据安全，MySQL让Master在<u>某一个时间点</u>等待Slave节点的 ACK（Acknowledge character）消息，接收到ACK消息后才进行事务提交，这也是半同步复制的基础，MySQL从5.5版本开始引入了半同步复制机制来**降低数据丢失的概率**。

MySQL 事务写入碰到主从复制时的完整过程，主库事务写入分为 4个步骤：

- InnoDB Redo File Write (Prepare Write)
- Binlog File Flush & Sync to Binlog File
- InnoDB Redo File Commit（Commit Write）
- Send Binlog to Slave（异步发送）

当Master不需要关注Slave是否接受到Binlog Event时，即为传统的主从复制。

当Master需要在第三步等待Slave返回ACK时，即为 after-commit，半同步复制（**MySQL 5.5引入**）。

当Master需要在第二步等待 Slave 返回 ACK 时，即为 after-sync，增强半同步（**MySQL 5.7引入**）。

------

没有收到ack可能会有这2种情况：

1， slave没接收到binlog，所以一直没回

2， slave收到binlog并且成功写入，返回给master的时候丢失。

after-commit在情况2的时候，master在没收到ack的情况重新发送，会出现slave重复提交数据的情况，after-sync只有在slave同步后，master再提交，可以避免情况2；

主库等待从库写入 relay log 并返回 ACK 后才进行Engine Commit，如下图所示

![img](https://blog.rubinchu.com/wp-content/uploads/2021/10/4-7-1024x448.png)

## 并行复制

MySQL从5.6版本开始追加了并行复制功能，目的就是为了改善复制延迟问题，并行复制称为enhanced multi-threaded slave（简称MTS）。

**为什么需要并行复制**

在从库中有两个线程IO Thread和SQL Thread，都是单线程模式工作，因此有了延迟问题，我们可以采用多线程机制来加强，减少从库复制延迟。（IO Thread多线程意义不大[因为SQL Thread跟不上消费依然会存在主从延迟的问题]，主要指的是SQL Thread多线程，相比SQL Thread要多）

**MySQL 5.6并行复制原理**

MySQL 5.6版本也支持所谓的并行复制，但是其并行只是基于库的。如果用户的MySQL数据库中是多个库，对于从库复制的速度的确可以有比较大的帮助。

![img](https://blog.rubinchu.com/wp-content/uploads/2021/10/5-6-1024x426.png)

![img](https://blog.rubinchu.com/wp-content/uploads/2021/10/6-6.png)

基于库的并行复制实现相对简单，使用也相对简单些。但是遇到单库多表使用场景就发挥不出优势，另外对事务并行处理的执行顺序也是个问题。

------

**MySQL 5.7并行复制原理**

基于<u>组提交</u>的并行复制，MySQL 5.7才可称为真正的并行复制，原因就是slave服务器的回放与master服务器是一致的，即master服务器上是怎么并行执行的slave上就怎样进行并行回放。不再有库的并行复制限制。

*如何实现*

- 当事务提交时，它们将在单个操作中写入到二进制日志中。如果多个事务能同时提交成功，那么它们意味着没有冲突，因此可以在Slave上并行执行，所以通过在主库上的二进制日志中添加组提交信息。

- 并行复制基于一个前提，即所有已经处于prepare阶段的事务，都是可以并行提交的。这些当然也可以在从库中并行提交，因为处理这个阶段的事务都是没有冲突的。在一个组里提交的事务，一定不会修改同一行。这是一种新的并行复制思路，完全摆脱了原来一直致力于为了防止冲突而做的分发算法，等待策略等复杂的而又效率底下的工作。

  > InnoDB事务提交采用的是两阶段提交模式。一个阶段是prepare，另一个是commit。

- 为了兼容MySQL 5.6基于库的并行复制，5.7引入了新的变量slave-parallel-type，其可以配置的值有：`DATABASE`（默认值，基于库的并行复制方式）、`LOGICAL_CLOCK`（基于组提交的并行复制方式）。



**如何知道事务是否在同一组中，生成的Binlog内容如何告诉Slave哪些事务是可以并行复制的？**

在MySQL 5.7版本中，其设计方式是将组提交的信息存放在`GTID`中。为了避免用户没有开启`GTID`功能（`gtid_mode=OFF`），MySQL 5.7又引入了称之为Anonymous_Gtid的二进制日志event类型`ANONYMOUS_GTID_LOG_EVENT`。

通过mysqlbinlog工具分析binlog日志，就可以发现组提交的内部信息。

![img](https://blog.rubinchu.com/wp-content/uploads/2021/10/7-5.png)

可以发现MySQL 5.7二进制日志较之原来的二进制日志内容多了`last_committed`和`sequence_number`.`last_committed`表示事务提交的时候，上次事务提交的编号，如果事务具有相同的`last_committed`，表示这些事务都在一组内，可以进行并行的回放。

------

**MySQL8.0 并行复制**

基于write-set的并行复制。MySQL会有一个集合变量来存储事务修改的记录信息（主键哈希值），所有已经提交的事务所修改的主键值经过hash后都会与那个变量的集合进行对比，来判断该行是否与其冲突，并以此来确定依赖关系，没有冲突即可并行。这样的粒度，就到了row级别了，此时并行的粒度更加精细，并行的速度会更快。

*调优与配置*

- `binlog_transaction_dependency_history_size`：用于控制集合变量的大小
- `binlog_transaction_depandency_tracking`：用于控制binlog文件中事务之间的依赖关系，即`last_committed`值（`COMMIT_ORDERE`: 基于组提交机制、`WRITESET`: 基于写集合机制、`WRITESET_SESSION`: 基于写集合，比`WRITESET`多了一个约束，同一个session中的事务）。`last_committed`按先后顺序递增
- `transaction_write_set_extraction`：用于控制事务的检测算法，参数值为：`OFF`、 `XXHASH64`、`MURMUR32`
- `master_info_repository`：开启MTS功能后，务必将参数`master_info_repostitory`设置为`TABLE`，这样性能可以有**50%~80%**的提升。这是因为并行复制开启后对于元master.info这个文件的更新将会大幅提升，资源的竞争也会变大
- `slave_parallel_workers`：若将`slave_parallel_workers`设置为0，则MySQL 5.7退化为原单线程复制，但将`slave_parallel_workers`设置为1，则SQL线程功能转化为coordinator线程，但是只有1个worker线程进行回放，也是单线程复制。然而，这两种性能却又有一些的区别，因为多了一次coordinator线程的转发，因此`slave_parallel_workers`=1的性能反而比0还要差
- `slave_preserve_commit_order`：MySQL 5.7后的MTS可以实现更小粒度的并行复制，但需要将`slave_parallel_type`设置为`LOGICAL_CLOCK`，但仅仅设置为`LOGICAL_CLOCK`也会存在问题，因为此时在slave上应用事务的顺序是无序的，和relay log中记录的事务顺序不一样，这样数据一致性是无法保证的，为了保证事务是按照relay log中记录的顺序来回放，就需要开启参数`slave_preserve_commit_order`

配置案例如下所示

```sql
slave-parallel-type=LOGICAL_CLOCK
slave-parallel-workers=16
slave_pending_jobs_size_max = 2147483648
slave_preserve_commit_order=1
master_info_repository=TABLE
relay_log_info_repository=TABLE
relay_log_recovery=ON
```

