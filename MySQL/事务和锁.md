# 事务

## ACID特性

在关系型数据库管理系统中，一个逻辑工作单元要成为事务，必须满足这4 个特性，即所谓的 ACID：原子性
(Atomicity）、一致性(Consistency）、隔离性( Isolation ）和持久性（ Durability)

### 原子性

原子性：事务是—个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
**修改--->Buffer Pool修改->刷盘**。可能会有下面2种情况：

1. 事务提交了，如果此时Buffer Pool的脏页没有刷盘，如何保证修改的数据生效？Redo
2. 如果事务没提交，但是Buffer Pool的脏页刷盘了，如何保证不该存在的数据撤销？Undo 

每一个写事务，都会修改BufferPool，从而产生相应的Redo/Undo日志，在Buffer Pool 中的页被刷到磁盘之前，
这些日志信息都会先写入到日志文件中【因为后台线程一般会在脏页到75%（比例可以调整）左右才会刷新到磁盘】

- 如果已经提交了事务， Buffer Pool 中的脏页没有刷成功，此时数据库挂了，那在数据库再次启动之后，可以通过 Redo 日志将其恢复出来，以保证脏页写的数据不会丢失。

- 如果事务还没有提交，脏页刷新成功，此时数据库挂了，就需要通过Undo来实现回滚。

### 持久性

![img](https://img-blog.csdnimg.cn/img_convert/7c5b64e74eb3fada377495d90d40d8ed.png)

一个“提交”动作触发的操作有：binlog 落地、发送 binlog、存储引擎提交（待了解）、flush_logs， check_point（待了解）、事务提交标记等。这些都是数据库保证其数据完整性、持久性的手段。   

MySQL的持久性也与WAL技术相关，redolog在系统Crash重启之类的情况时，可以修复数据，从而保障事务的持
久性。通过原子性可以保证逻辑上的持久性，通过存储引擎的数据刷盘可以保证物理上的持久性。

[事务提交的流程！！！！](https://www.cnblogs.com/konggg/p/12621401.html)

### 隔离性

指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并发事务是隔离的。

隔离性由低到高：读未提交，读提交，可重复度，串行化。

锁和多版本控制就符合隔离性。

### 一致性

指的是事务开始之前和事务结束之后，数据库的完整性限制未被破坏。一致性包括两方面的内
容，分别是约束一致性和数据一致性。

**数据一致性：**是一个综合性的规定，因为它是由原子性、持久性、隔离性共同保证的结果，而不是
单单依赖于某一种技术。

![img](https://img-blog.csdnimg.cn/img_convert/608875d8db37f9c4c2931cae47b7296e.png)



> WAL的全称为Write-Ahead Logging，先写日志，再写磁盘。

ACID 及它们之间的关系如下图所示，**4个特性中有3个与 WAL 有关系**，都需要通过 Redo、Undo 日志
来保证等。

![img](https://img-blog.csdnimg.cn/img_convert/e8e3db8290de5beae4f3addf672bdb2e.png)

## 并发

事务并发处理可能会带来一些问题，比如：更新丢失、脏读、不可重复读、幻读等。

更新丢失

- 当两个或多个事务更新同一行记录，会产生更新丢失现象。可以分为回滚覆盖和提交覆盖。

  -  回滚覆盖：一个事务回滚操作，把其他事务已提交的数据给覆盖了。

  - 提交覆盖：一个事务提交操作，把其他事务已提交的数据给覆盖了。

脏读

- 一个事务读取到了另一个事务修改但未提交的数据。

不可重复读

- 一个事务中多次读取同一行记录不一致，后面读取的跟前面读取的不一致。

幻读

- 一个事务中多次按相同条件查询，结果不一致。后续查询的结果和面前查询结果不同，多了或少了
  几行记录。

## 排他锁

引入锁之后就可以支持并发处理事务，如果事务之间涉及到相同的数据项时，会使用排他锁，或叫互斥
锁，先进入的事务独占数据项以后，其他事务被阻塞，等待前面的事务释放锁。

![img](https://img-blog.csdnimg.cn/img_convert/ed88238e70dcb15a073133e35ad4a041.png)

## 读写锁

读和写操作：读读、写写、读写、写读。读写锁，可以让读和读并行，而读和写、写和读、写和写这几种之间还是要加排他锁。

## MVCC

多版本控制MVCC，也就是Copy on Write的思想。MVCC除了支持读和读并行，还支持读和写、写和读的并行，但为了保证一致性，写和写是无法并行。

![img](https://img-blog.csdnimg.cn/img_convert/416c4c279909cf20c83aca596d35c6e6.png)

在事务1开始写操作的时候会copy一个记录的副本，其他事务读操作会读取这个记录副本，因此不会影响其他事务对此记录的读取，实现**读和写**并发。

**概念**

MVCC（Multi Version Concurrency Control）被称为多版本控制，是指在数据库中为了实现高并发的数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。多版本控制很巧妙地将稀缺资源的独占互斥转换为并发，大大提高了数据库的吞吐量及读写性能。

**如何生成的多版本？**

每次事务修改操作之前，都会在<u>Undo</u>日志中记录修改之前的数据状态和事务号，该备份记录可以用于其他事务的读取，也可以进行必要时的数据回滚。

**原理**

目前MVCC只在 `Read Commited `和 `Repeatable Read` 两种隔离级别下工作。在 MVCC 并发控制中，读操作可以分为两类: 快照读（Snapshot Read）与当前读 （Current Read）。 

- 快照读：读取的是记录的快照版本（有可能是历史版本），不用加锁。（select），对应着  `Repeatable Read` ，每次都读取快照，从而避免不可重复读。
- 当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发修改这条记录。（select… for update 或lock in share mode，insert/delete/update），对应着`Read Commited `，会出现不可重复度的现象。

**案例**

假设 F1～F6 是表中字段的名字，1～6 是其对应的数据。后面三个隐含字段分别对应该行的隐含ID、事务号和回滚指针，如下图所示。

![img](https://img-blog.csdnimg.cn/img_convert/5af95eb363a047109d1777bc37327532.png)



假如一条数据是刚 INSERT 的，DB_ROW_ID 为 1，其他两个字段为空。当事务 1 更改该行的数据值时，会进行如下操作，如下图所示。

![img](https://img-blog.csdnimg.cn/img_convert/6a1a2c05a5fcafcd9c31d8f05ffe0c86.png)

- 用排他锁对此条记录进行锁定，并且记录Redo log。
- 把当前行的修改前的值复制到Undo log。
- 修改当前行，填充事务编号，并且设置回滚指针指向undo log的所复制的行。



事务2操作，过程与事务 1 相同，此时 Undo log 中会有两行记录，并且通过回滚指针连在一起，通过当前记录的回滚指针回溯到该行创建时的初始内容，如下图所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201215184645170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzE0OTcy,size_16,color_FFFFFF,t_70)



**按照这种机制加载的话，Undo log中的记录会越来越多的，内存溢出怎么办？**

InnoDB的线程模型中有一个Purge Thread`（事务提交之后，其使用的undo日志将不再需要，因此需要Purge Thread回收已经分配的undo页）`会释放内存，但有个前提，在可重复读的隔离级别下，若其他事务还在读此条记录的undo日志记录，并且其他事务还没结束，那么此条被引用的记录则不会释放内存删除，只有undo日志里的记录没有被其他事务引用，则可以被释放。

## 隔离级别 

## 锁分类

从操作的粒度可分为表级锁、行级锁和页级锁。

**表级锁**：每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在
MyISAM、InnoDB、BDB 等存储引擎中。

**行级锁**：每次操作锁住一行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应
用在InnoDB 存储引擎中。

**页级锁**：每次锁定相邻的一组记录，锁定粒度界于表锁和行锁之间，开销和加锁时间界于表
锁和行锁之间，并发度一般。应用在BDB 存储引擎中。

**从操作的类型可分为读锁和写锁。（针对于行锁）**

- 读锁（S锁）：共享锁，针对同一份数据，多个读操作可以同时进行而不会互相影响。
- 写锁（X锁）：排他锁，当前写操作没有完成前，它会阻断其他写锁和读锁。

IS 锁（intentional share）、IX（intentional exclusive）锁：意向读锁、意向写锁，属于表级锁，S和X主要针对行级锁，在对表记录添加S或X锁之前，会先对**表**添加IS或IX锁，其他事务在进行加锁的时候可以进行与判断，在行级锁的情况下，不需要每行去判断是否加锁，在数据量较大的情况下，提高判断效率。



S锁：事务A对记录添加了S锁，可以对记录进行读操作，不能做修改，其他事务可以对该记录追加S锁，但是不能追加X锁；如果需要追加X锁，需要等记录的S锁全部释放。

X锁：事务A对记录添加了X锁，可以对记录进行读和修改操作，其他事务不能对记录做读和修改操

**从操作的性能可分为乐观锁和悲观锁。**

- 乐观锁：一般的实现方式是对记录数据版本**进行比对**，在数据更新提交的时候才会进行冲突
  检测，如果发现冲突了，则提示错误信息。
- 悲观锁：在对一条数据修改的时候，为了避免同时被其他人修改，在修改数据之前先锁定，
  再修改的控制方式。共享锁和排他锁是悲观锁的不同实现，但都属于悲观锁范畴。

### 行锁

**原理**

其中行锁又分为共享锁和排他锁。InnoDB行锁通过对**索引数据页**的记录加锁实现，有3种实现算法：

- Record Lock（行锁，RC、RR隔离级别都支持）
- GapLock：间隙锁，锁定索引记录间隙，确保索引记录的间隙不变。（范围锁，RR隔离级别支
  持）
- Next-key Lock 锁：记录锁和间隙锁组合，同时锁住数据，并且锁住数据前后范围。（记录锁+范
  围锁，RR隔离级别支持）

在<u>RR隔离级别</u>，InnoDB对于记录加锁行为都是先采用Next-Key Lock，但是当SQL操作含有**唯一索引**
时，Innodb会对Next-Key Lock进行优化，降级为RecordLock，仅锁住索引本身而非范围。（Next-Key Lock -> Record Lock）

```sql
select … from 语句：InnoDB引擎采用MVCC机制实现非阻塞读，所以对于普通的select语句，InnoDB不加锁

select … from lock in share mode语句：追加了共享锁，InnoDB会使用Next-Key Lock锁进行处
理，如果扫描发现唯一索引，可以降级为RecordLock锁。

select … from for update语句：追加了排他锁，InnoDB会使用Next-Key Lock锁进行处理，如果扫
描发现唯一索引，可以降级为RecordLock锁。

update … where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以
降级为RecordLock锁。

delete … where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以降
级为RecordLock锁。

insert语句：InnoDB会在将要插入的那一行设置一个排他的RecordLock锁。
```

**案例**

以`update t1 set name=‘XX’ where id=10`操作为例，举例子分析下 InnoDB 对不同索引的加锁行为，以<u>RR隔离级别</u>为例。

1， 主键加锁，仅在id=10的主键索引记录上加X锁。

![img](https://img-blog.csdnimg.cn/img_convert/b3b70d5044a7bd75fa437fb66c39ba5c.png)

2， 唯一键加锁，现在唯一索引id上加X锁，然后在id=10的主键索引记录上加X锁。

![img](https://img-blog.csdnimg.cn/img_convert/5a0b96920c0eebfaa750f4befbfdc397.png)

3， 非唯一键加锁，对满足id=10条件的记录和主键分别加X锁，然后在(6,c)-(10,b)、(10,b)-(10,d)、(10,d)-(11,f)范围分别加Gap Lock。

![img](https://img-blog.csdnimg.cn/img_convert/47ceca51509aced3367b195a45abf368.png)

4， 无索引加锁，表里所有行和间隙都会加X锁。（当没有索引时，会导致全表锁定，因为InnoDB引擎锁机制是基于索引实现的记录锁定）
