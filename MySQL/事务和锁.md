# 事务

## ACID特性

在关系型数据库管理系统中，一个逻辑工作单元要成为事务，必须满足这4 个特性，即所谓的 ACID：原子性
(Atomicity）、一致性(Consistency）、隔离性( Isolation ）和持久性（ Durability)

### 原子性

原子性：事务是—个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
**修改--->Buffer Pool修改->刷盘**。可能会有下面2种情况：

1. 事务提交了，如果此时Buffer Pool的脏页没有刷盘，如何保证修改的数据生效？Redo
2. 如果事务没提交，但是Buffer Pool的脏页刷盘了，如何保证不该存在的数据撤销？Undo 

每一个写事务，都会修改BufferPool，从而产生相应的Redo/Undo日志，在Buffer Pool 中的页被刷到磁盘之前，
这些日志信息都会先写入到日志文件中【因为后台线程一般会在脏页到75%（比例可以调整）左右才会刷新到磁盘】

- 如果已经提交了事务， Buffer Pool 中的脏页没有刷成功，此时数据库挂了，那在数据库再次启动之后，可以通过 Redo 日志将其恢复出来，以保证脏页写的数据不会丢失。

- 如果事务还没有提交，脏页刷新成功，此时数据库挂了，就需要通过Undo来实现回滚。

### 持久性

![img](https://img-blog.csdnimg.cn/img_convert/7c5b64e74eb3fada377495d90d40d8ed.png)

一个“提交”动作触发的操作有：binlog 落地、发送 binlog、存储引擎提交（待了解）、flush_logs， check_point（待了解）、事务提交标记等。这些都是数据库保证其数据完整性、持久性的手段。   

MySQL的持久性也与WAL技术相关，redolog在系统Crash重启之类的情况时，可以修复数据，从而保障事务的持
久性。通过原子性可以保证逻辑上的持久性，通过存储引擎的数据刷盘可以保证物理上的持久性。

[事务提交的流程！！！！](https://www.cnblogs.com/konggg/p/12621401.html)

### 隔离性

指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并发事务是隔离的。

隔离性由低到高：读未提交，读提交，可重复度，串行化。

锁和多版本控制就符合隔离性。

### 一致性

指的是事务开始之前和事务结束之后，数据库的完整性限制未被破坏。一致性包括两方面的内
容，分别是约束一致性和数据一致性。

**数据一致性：**是一个综合性的规定，因为它是由原子性、持久性、隔离性共同保证的结果，而不是
单单依赖于某一种技术。

![img](https://img-blog.csdnimg.cn/img_convert/608875d8db37f9c4c2931cae47b7296e.png)



> WAL的全称为Write-Ahead Logging，先写日志，再写磁盘。

ACID 及它们之间的关系如下图所示，**4个特性中有3个与 WAL 有关系**，都需要通过 Redo、Undo 日志
来保证等。

![img](https://img-blog.csdnimg.cn/img_convert/e8e3db8290de5beae4f3addf672bdb2e.png)

## 并发

事务并发处理可能会带来一些问题，比如：更新丢失、脏读、不可重复读、幻读等。

更新丢失

- 当两个或多个事务更新同一行记录，会产生更新丢失现象。可以分为回滚覆盖和提交覆盖。

  -  回滚覆盖：一个事务回滚操作，把其他事务已提交的数据给覆盖了。

  - 提交覆盖：一个事务提交操作，把其他事务已提交的数据给覆盖了。

脏读

- 一个事务读取到了另一个事务修改但未提交的数据。

不可重复读

- 一个事务中多次读取同一行记录不一致，后面读取的跟前面读取的不一致。

幻读

- 一个事务中多次按相同条件查询，结果不一致。后续查询的结果和面前查询结果不同，多了或少了
  几行记录。

## 排他锁

引入锁之后就可以支持并发处理事务，如果事务之间涉及到相同的数据项时，会使用排他锁，或叫互斥
锁，先进入的事务独占数据项以后，其他事务被阻塞，等待前面的事务释放锁。

![img](https://img-blog.csdnimg.cn/img_convert/ed88238e70dcb15a073133e35ad4a041.png)

## 读写锁

读和写操作：读读、写写、读写、写读。读写锁，可以让读和读并行，而读和写、写和读、写和写这几种之间还是要加排他锁。

## MVCC

多版本控制MVCC，也就是Copy on Write的思想。MVCC除了支持读和读并行，还支持读和写、写和读的并行，但为了保证一致性，写和写是无法并行。

![img](https://img-blog.csdnimg.cn/img_convert/416c4c279909cf20c83aca596d35c6e6.png)

在事务1开始写操作的时候会copy一个记录的副本，其他事务读操作会读取这个记录副本，因此不会影响其他事务对此记录的读取，实现**读和写**并发。

**概念**

MVCC（Multi Version Concurrency Control）被称为多版本控制，是指在数据库中为了实现高并发的数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。多版本控制很巧妙地将稀缺资源的独占互斥转换为并发，大大提高了数据库的吞吐量及读写性能。

**如何生成的多版本？**

每次事务修改操作之前，都会在<u>Undo</u>日志中记录修改之前的数据状态和事务号，该备份记录可以用于其他事务的读取，也可以进行必要时的数据回滚。

**原理**

目前MVCC只在 `Read Commited `和 `Repeatable Read` 两种隔离级别下工作。在 MVCC 并发控制中，读操作可以分为两类: 快照读（Snapshot Read）与当前读 （Current Read）。 

- 快照读：读取的是记录的快照版本（有可能是历史版本），不用加锁。（select），对应着  `Repeatable Read` ，每次都读取快照，从而避免不可重复读。
- 当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发修改这条记录。（select… for update 或lock in share mode，insert/delete/update），对应着`Read Commited `，会出现不可重复度的现象。

**案例**

假设 F1～F6 是表中字段的名字，1～6 是其对应的数据。后面三个隐含字段分别对应该行的隐含ID、事务号和回滚指针，如下图所示。

![img](https://img-blog.csdnimg.cn/img_convert/5af95eb363a047109d1777bc37327532.png)



假如一条数据是刚 INSERT 的，DB_ROW_ID 为 1，其他两个字段为空。当事务 1 更改该行的数据值时，会进行如下操作，如下图所示。

![img](https://img-blog.csdnimg.cn/img_convert/6a1a2c05a5fcafcd9c31d8f05ffe0c86.png)

- 用排他锁对此条记录进行锁定，并且记录Redo log。
- 把当前行的修改前的值复制到Undo log。
- 修改当前行，填充事务编号，并且设置回滚指针指向undo log的所复制的行。



事务2操作，过程与事务 1 相同，此时 Undo log 中会有两行记录，并且通过回滚指针连在一起，通过当前记录的回滚指针回溯到该行创建时的初始内容，如下图所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201215184645170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzE0OTcy,size_16,color_FFFFFF,t_70)



**按照这种机制加载的话，Undo log中的记录会越来越多的，内存溢出怎么办？**

InnoDB的线程模型中有一个Purge Thread`（事务提交之后，其使用的undo日志将不再需要，因此需要Purge Thread回收已经分配的undo页）`会释放内存，但有个前提，在可重复读的隔离级别下，若其他事务还在读此条记录的undo日志记录，并且其他事务还没结束，那么此条被引用的记录则不会释放内存删除，只有undo日志里的记录没有被其他事务引用，则可以被释放。
