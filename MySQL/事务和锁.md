# 事务

## ACID特性

在关系型数据库管理系统中，一个逻辑工作单元要成为事务，必须满足这4 个特性，即所谓的 ACID：原子性
(Atomicity）、一致性(Consistency）、隔离性( Isolation ）和持久性（ Durability)

### 原子性

原子性：事务是—个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
**修改--->Buffer Pool修改->刷盘**。可能会有下面2种情况：

1. 事务提交了，如果此时Buffer Pool的脏页没有刷盘，如何保证修改的数据生效？Redo
2. 如果事务没提交，但是Buffer Pool的脏页刷盘了，如何保证不该存在的数据撤销？Undo 

每一个写事务，都会修改BufferPool，从而产生相应的Redo/Undo日志，在Buffer Pool 中的页被刷到磁盘之前，
这些日志信息都会先写入到日志文件中【因为后台线程一般会在脏页到75%（比例可以调整）左右才会刷新到磁盘】

- 如果已经提交了事务， Buffer Pool 中的脏页没有刷成功，此时数据库挂了，那在数据库再次启动之后，可以通过 Redo 日志将其恢复出来，以保证脏页写的数据不会丢失。

- 如果事务还没有提交，脏页刷新成功，此时数据库挂了，就需要通过Undo来实现回滚。

### 持久性

![img](https://img-blog.csdnimg.cn/img_convert/7c5b64e74eb3fada377495d90d40d8ed.png)

一个“提交”动作触发的操作有：binlog 落地、发送 binlog、存储引擎提交（待了解）、flush_logs， check_point（待了解）、事务提交标记等。这些都是数据库保证其数据完整性、持久性的手段。   

MySQL的持久性也与WAL技术相关，redolog在系统Crash重启之类的情况时，可以修复数据，从而保障事务的持
久性。通过原子性可以保证逻辑上的持久性，通过存储引擎的数据刷盘可以保证物理上的持久性。

[事务提交的流程！！！！](https://www.cnblogs.com/konggg/p/12621401.html)

### 隔离性

指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并发事务是隔离的。

隔离性由低到高：读未提交，读提交，可重复度，串行化。

锁和多版本控制就符合隔离性。

### 一致性

指的是事务开始之前和事务结束之后，数据库的完整性限制未被破坏。一致性包括两方面的内
容，分别是约束一致性和数据一致性。

**数据一致性：**是一个综合性的规定，因为它是由原子性、持久性、隔离性共同保证的结果，而不是
单单依赖于某一种技术。

![img](https://img-blog.csdnimg.cn/img_convert/608875d8db37f9c4c2931cae47b7296e.png)



> WAL的全称为Write-Ahead Logging，先写日志，再写磁盘。

ACID 及它们之间的关系如下图所示，**4个特性中有3个与 WAL 有关系**，都需要通过 Redo、Undo 日志
来保证等。

![img](https://img-blog.csdnimg.cn/img_convert/e8e3db8290de5beae4f3addf672bdb2e.png)

## 并发

事务并发处理可能会带来一些问题，比如：更新丢失、脏读、不可重复读、幻读等。

更新丢失

- 当两个或多个事务更新同一行记录，会产生更新丢失现象。可以分为回滚覆盖和提交覆盖。

  -  回滚覆盖：一个事务回滚操作，把其他事务已提交的数据给覆盖了。

  - 提交覆盖：一个事务提交操作，把其他事务已提交的数据给覆盖了。

脏读

- 一个事务读取到了另一个事务修改但未提交的数据。

不可重复读

- 一个事务中多次读取同一行记录不一致，后面读取的跟前面读取的不一致。

幻读

- 一个事务中多次按相同条件查询，结果不一致。后续查询的结果和面前查询结果不同，多了或少了
  几行记录。

## 排他锁

引入锁之后就可以支持并发处理事务，如果事务之间涉及到相同的数据项时，会使用排他锁，或叫互斥
锁，先进入的事务独占数据项以后，其他事务被阻塞，等待前面的事务释放锁。

![img](https://img-blog.csdnimg.cn/img_convert/ed88238e70dcb15a073133e35ad4a041.png)

## 读写锁

读和写操作：读读、写写、读写、写读。读写锁，可以让读和读并行，而读和写、写和读、写和写这几种之间还是要加排他锁。

## MVCC

多版本控制MVCC，也就是Copy on Write的思想。MVCC除了支持读和读并行，还支持读和写、写和读的并行，但为了保证一致性，写和写是无法并行。

![img](https://img-blog.csdnimg.cn/img_convert/416c4c279909cf20c83aca596d35c6e6.png)

在事务1开始写操作的时候会copy一个记录的副本，其他事务读操作会读取这个记录副本，因此不会影响其他事务对此记录的读取，实现**读和写**并发。

**概念**

MVCC（Multi Version Concurrency Control）被称为多版本控制，是指在数据库中为了实现高并发的数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。多版本控制很巧妙地将稀缺资源的独占互斥转换为并发，大大提高了数据库的吞吐量及读写性能。

**如何生成的多版本？**

每次事务修改操作之前，都会在<u>Undo</u>日志中记录修改之前的数据状态和事务号，该备份记录可以用于其他事务的读取，也可以进行必要时的数据回滚。

**原理**

目前MVCC只在 `Read Commited `和 `Repeatable Read` 两种隔离级别下工作。在 MVCC 并发控制中，读操作可以分为两类: 快照读（Snapshot Read）与当前读 （Current Read）。 

- 快照读：读取的是记录的快照版本（有可能是历史版本），不用加锁。（select），对应着  `Repeatable Read` ，每次都读取快照，从而避免不可重复读。
- 当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发修改这条记录。（select… for update 或lock in share mode，insert/delete/update），对应着`Read Commited `，会出现不可重复度的现象。

**案例**

假设 F1～F6 是表中字段的名字，1～6 是其对应的数据。后面三个隐含字段分别对应该行的隐含ID、事务号和回滚指针，如下图所示。

![img](https://img-blog.csdnimg.cn/img_convert/5af95eb363a047109d1777bc37327532.png)



假如一条数据是刚 INSERT 的，DB_ROW_ID 为 1，其他两个字段为空。当事务 1 更改该行的数据值时，会进行如下操作，如下图所示。

![img](https://img-blog.csdnimg.cn/img_convert/6a1a2c05a5fcafcd9c31d8f05ffe0c86.png)

- 用排他锁对此条记录进行锁定，并且记录Redo log。
- 把当前行的修改前的值复制到Undo log。
- 修改当前行，填充事务编号，并且设置回滚指针指向undo log的所复制的行。



事务2操作，过程与事务 1 相同，此时 Undo log 中会有两行记录，并且通过回滚指针连在一起，通过当前记录的回滚指针回溯到该行创建时的初始内容，如下图所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201215184645170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzE0OTcy,size_16,color_FFFFFF,t_70)



**按照这种机制加载的话，Undo log中的记录会越来越多的，内存溢出怎么办？**

InnoDB的线程模型中有一个Purge Thread`（事务提交之后，其使用的undo日志将不再需要，因此需要Purge Thread回收已经分配的undo页）`会释放内存，但有个前提，在可重复读的隔离级别下，若其他事务还在读此条记录的undo日志记录，并且其他事务还没结束，那么此条被引用的记录则不会释放内存删除，只有undo日志里的记录没有被其他事务引用，则可以被释放。

## 隔离级别 

## 锁分类

从操作的粒度可分为表级锁、行级锁和页级锁。

**表级锁**：每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB 等存储引擎中。

**行级锁**：每次操作锁住一行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB 存储引擎中。

**页级锁**：每次锁定相邻的一组记录，锁定粒度界于表锁和行锁之间，开销和加锁时间界于表锁和行锁之间，并发度一般。应用在BDB 存储引擎中。

**从操作的类型可分为读锁和写锁。（针对于行锁）**

- 读锁（S锁）：共享锁，针对同一份数据，多个读操作可以同时进行而不会互相影响。
- 写锁（X锁）：排他锁，当前写操作没有完成前，它会阻断其他写锁和读锁。

IS 锁（intentional share）、IX（intentional exclusive）锁：意向读锁、意向写锁，属于表级锁，S和X主要针对行级锁，在对表记录添加S或X锁之前，会先对**表**添加IS或IX锁，其他事务在进行加锁的时候可以进行与判断，在行级锁的情况下，不需要每行去判断是否加锁，在数据量较大的情况下，提高判断效率。



S锁：事务A对记录添加了S锁，可以对记录进行读操作，不能做修改，其他事务可以对该记录追加S锁，但是不能追加X锁；如果需要追加X锁，需要等记录的S锁全部释放。

X锁：事务A对记录添加了X锁，可以对记录进行读和修改操作，其他事务不能对记录做读和修改操

**从操作的性能可分为乐观锁和悲观锁。**

- 乐观锁：一般的实现方式是对记录数据版本**进行比对**，在数据更新提交的时候才会进行冲突
  检测，如果发现冲突了，则提示错误信息。
- 悲观锁：在对一条数据修改的时候，为了避免同时被其他人修改，在修改数据之前先锁定，
  再修改的控制方式。共享锁和排他锁是悲观锁的不同实现，但都属于悲观锁范畴。

### [行锁](https://juejin.cn/post/7165718793849667620)

**原理**

其中行锁又分为共享锁和排他锁。InnoDB行锁通过对**索引数据页**的记录加锁实现，有3种实现算法：

- Record Lock（行锁，RC、RR隔离级别都支持），其他事务就无法对加锁的记录进行修改和删除。
- GapLock：间隙锁，锁定索引记录间隙，确保索引记录的间隙不变。（范围锁，RR隔离级别支持），只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象，**两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的**。
- Next-key Lock 锁：记录锁和间隙锁组合，同时锁住数据，并且锁住数据前后范围。（记录锁+范围锁，RR隔离级别支持）

在<u>RR隔离级别</u>，InnoDB对于记录加锁行为都是先采用Next-Key Lock，但是当SQL操作含有**唯一索引**时，Innodb会对Next-Key Lock进行优化，降级为RecordLock，仅锁住索引本身而非范围。（Next-Key Lock -> Record Lock）

加锁的对象是索引，加锁的基本单位是 next-key lock，它是由**记录锁和间隙锁组合**而成的，next-key lock 是前开后闭区间，而间隙锁是前开后开区间。

⚠️next-key lock 在一些场景下会退化成记录锁或间隙锁，在可重复隔离级别下进行，因为需要解决幻读的问题，才引入的间隙锁。

#### **唯一索引加锁规则**

唯一索引进行范围查询时，会对每一个扫描到的索引加 next-key 锁，在某些情况下会退化为行记录锁或者间隙锁

**等值查询**

- 当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会**退化成「记录锁」**。
- 当查询的记录是「不存在」的，则会在索引树找到第一条大于该查询记录的记录，然后将该记录的索引中的 next-key lock 会**退化成「间隙锁」**。

**范围查询**

当唯一索引进行范围查询时，会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁，会有以下两种情况。

情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会**退化成记录锁**。

情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：

- 当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会**退化成间隙锁**，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。
- 当条件值的记录在表中，如果是「小于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会**退化成间隙锁**，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。

![行级锁-唯一索引](https://gitee.com/JieMingLi/document-pics/raw/master/%E8%A1%8C%E7%BA%A7%E9%94%81-%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95.jpeg)



#### **非唯一索引加锁规则**

用非唯一索引进行等值查询的时候，**因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，**⚠️**但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁**。

<u>等值查询加锁规则</u>

- 当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是**非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁**。
- 当查询的记录「不存在」时，**扫描到第一条不符合条件的二级索引记录，该二级索引的** **next-key** **锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁**。

<u>范围查询加锁规则</u>

- 非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于**非唯一索引范围查询，索引的** **next-key lock** **不会有退化为间隙锁和记录锁的情况**，也就是非唯一索引进行范围查询时，**对二级索引记录加锁都是加** **next-key** **锁。**

![行级锁-非唯一索引](https://gitee.com/JieMingLi/document-pics/raw/master/%E8%A1%8C%E7%BA%A7%E9%94%81-%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95.jpeg)



**问题**

当有一个事务持有二级索引的间隙锁 (22, 39) 时，什么情况下，可以让其他事务的插入 age = 22 或者 age = 39 记录的语句成功？又是什么情况下，插入 age = 22 或者 age = 39 记录时的语句会被阻塞？

![img](https://gitee.com/JieMingLi/document-pics/raw/master/29f2b50abbe84528a5eb9310377624d8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0-20221126175249632-20221126175254099.awebp)

当有一个事务持有二级索引的间隙锁 (22, 39) 时，插入 age = 22 或者 age = 39 记录的语句是否可以执行成功，关键还要考虑插入记录的主键值，根据上图有以下的新数据能否插入的情况。

| **age** | **id** | **是否可以插入** |
| ------- | ------ | ---------------- |
| 22      | 3      | 可以             |
| 22      | 13     | 不可以           |
| 39      | 15     | 不可以           |
| 39      | 21     | 可以             |

**结论：【二级索引值（age列）+主键值（id列）】才可以确定插入的位置，确定了插入位置后，就要看插入的位置的下一条记录是否有间隙锁，如果有间隙锁，就会发生阻塞，如果没有间隙锁，则可以插入成功。**

#### **不走索引加锁规则**

- 如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。
- update 和 delete 语句如果查询条件不加索引，那么由于扫描的方式是全表扫描，于是就会对每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表。
- ⚠️<u>在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了</u>

**场景**

```sql
select … from 语句：InnoDB引擎采用MVCC机制实现非阻塞读，所以对于普通的select语句，InnoDB不加锁

select … from lock in share mode语句：追加了共享锁，InnoDB会使用Next-Key Lock锁进行处
理，如果扫描发现唯一索引，可以降级为RecordLock锁。

select … from for update语句：追加了排他锁，InnoDB会使用Next-Key Lock锁进行处理，如果扫
描发现唯一索引，可以降级为RecordLock锁。

update … where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以
降级为RecordLock锁。

delete … where 语句：InnoDB会使用Next-Key Lock锁进行处理，如果扫描发现唯一索引，可以降
级为RecordLock锁。

insert语句：InnoDB会在将要插入的那一行设置一个排他的RecordLock锁。
```

**案例**

以`update t1 set name=‘XX’ where id=10`操作为例，举例子分析下 InnoDB 对不同索引的加锁行为，以<u>RR隔离级别</u>为例。

1， 主键加锁，仅在id=10的主键索引记录上加X锁。

![img](https://img-blog.csdnimg.cn/img_convert/b3b70d5044a7bd75fa437fb66c39ba5c.png)

2， 唯一键加锁，现在唯一索引id上加X锁，然后在id=10的主键索引记录上加X锁。

![img](https://img-blog.csdnimg.cn/img_convert/5a0b96920c0eebfaa750f4befbfdc397.png)

3， 非唯一键加锁，对满足id=10条件的记录和主键分别加X锁，然后在(6,c)-(10,b)、(10,b)-(10,d)、(10,d)-(11,f)范围分别加Gap Lock。

![img](https://img-blog.csdnimg.cn/img_convert/47ceca51509aced3367b195a45abf368.png)

4， 无索引加锁，表里所有行和间隙都会加X锁。（当没有索引时，会导致全表锁定，因为InnoDB引擎锁机制是基于索引实现的记录锁定）

![img](https://img-blog.csdnimg.cn/img_convert/bd45c069fbb64d04d59d53f3c1c56340.png)







### 悲观锁

指在数据处理过程，将数据处于锁定状态，一般使用数据库的锁机制实现。

从广义上来讲，前面提到的**行锁、表锁、读锁、写锁、共享锁、排他锁**等，这些都属于悲观锁范畴。

**表级锁**
表级锁每次操作都锁住整张表，并发度最低 
表级读锁

- 当前表追加read锁，当前连接和其他的连接都可以读操作；但是当前连接增删改操作
  会报错，其他连接增删改会被阻塞。

表级写锁

- 当前表追加write锁，当前连接可以对表做增删改查操作，其他连接对该表所有操作都
  被阻塞（包括查询）。

总结：表级读锁会阻塞写操作，但是不会阻塞读操作。而写锁则会把读和写操作都阻塞。

------

**共享锁（行级锁-读锁）**
共享锁又称为读锁，简称S锁。共享锁就是多个事务对于**同一数据**可以共享一把锁，都能访问到数
据，但是只能读不能修改。使用共享锁的方法是在`select … lock in share mode`，只适用查询语
句。
总结：事务使用了共享锁（读锁），只能读取，不能修改，修改操作被阻塞。

------

**排他锁（行级锁-写锁）**
排他锁又称为写锁，简称X锁。排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排
他锁，其他事务就不能对该行记录做其他操作，也不能获取该行的锁。

> 使用排他锁的方法是在SQL末尾加上for update，innodb引擎默认会在update，delete语句加上
> for update。行级锁的实现其实是依靠其对应的索引，所以如果操作没用到索引的查询，那么会锁
> 住全表记录。

总结：事务使用了排他锁（写锁），当前事务可以读取和修改，其他事务不能修改，也不能获取记录
锁（select… for update）。如果查询没有使用到索引，将会锁住整个表记录。

### 乐观锁

乐观锁是相对于悲观锁而言的，它不是数据库提供的功能，<u>需要开发者自己去实现</u>。在数据库操作时，
想法很乐观，认为这次的操作不会导致冲突，因此在数据库操作时并不做任何的特殊处理，即不加锁，
而是在进行事务提交时再去判断是否有冲突了。

**根据业务场景选择乐观锁和悲观锁**

悲观锁和乐观锁都可以解决事务写写并发，在应用中可以根据并发处理能力选择区分，比如对并发率要
求高的选择乐观锁；对于并发率要求低的可以选择悲观锁。

**原理**

1， 使用版本字段（version）

先给数据表增加一个版本(version) 字段，每操作一次，将那条记录的版本号加 1。version是用来查看被读的记录有无变化，作用是防止记录在业务处理期间被其他事务修改。

![img](https://img-blog.csdnimg.cn/img_convert/6ccbd9b615940b46e071e71b860faac9.png)

2， 使用时间戳（Timestamp）

与使用version版本字段相似，同样需要给在数据表增加一个字段，字段类型使用timestamp时间戳。也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则提交更新，否则就是版本冲突，取消操作。

> 许多数据库访问框架也封装了乐观锁的实现，比如hibernate框架。MyBatis框架大家可以使用OptimisticLocker插件来扩展。

###  死锁

**表锁死锁**

用户A访问表A（锁住了表A），然后又访问表B；另一个用户B访问表B（锁住了表B），然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。

- 用户A–》A表（表锁）–》B表（表锁）
- 用户B–》B表（表锁）–》A表（表锁）

<u>解决方案</u>

这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，对于数据库的多表操作时，尽量<u>按照相同的顺序进行处理，尽量避免同时锁定两个资源</u>，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。

**行级锁死锁**

**情况1**

如果在事务中执行了一条**没有索引条件**的查询，引发全表扫描，把行级锁上升为全表记录锁定（等价于表级锁），多个这样的事务执行后，就很容易产生死锁和阻塞，最终应用系统会越来越慢，发生阻塞或死锁。

解决方案：SQL语句中不要使用太复杂的<u>关联</u>（在公司中会出现禁止联表查询的操作）多表的查询；使用explain“执行计划"对SQL语句进行分析，对于有全表扫描和全表锁定的SQL语句，建立相应的索引进行优化。

**情况2**

两个事务分别想拿到对方持有的锁，互相等待，于是产生死锁。

![img](https://img-blog.csdnimg.cn/img_convert/3eda805a756e68f5c199d52598678fca.png)

解决方案如下

1. 在同一个事务中，尽可能做到**一次**锁定所需要的所有资源。
2. 按照id对资源排序，然后按**顺序**进行处理。
3. 共享锁转换为排他锁。

**情况3**

1， 事务A 查询一条纪录，然后更新该条纪录

2， 此时事务B 也更新该条纪录，这时事务B 的排他锁由于事务A 有共享锁，必须等A 释放共享锁后才可以获取，只能排队等待

3， 事务A 再执行更新操作时，此处发生死锁，因为事务A 需要排他锁来做更新操作。但是无法授予该锁请求，因为事务B 已经
有一个排他锁请求，并且正在等待事务A 释放其共享锁。

```sql
事务A: select * from dept where deptno=1 lock in share mode; //共享锁,1
update dept set dname='java' where deptno=1;//排他锁,3
------------------------------------------------------------
事务B: update dept set dname='Java' where deptno=1;//由于1有共享锁，没法获取排他锁，需等待，2
```

解决方案

1， 避免引发同时对同一条记录多次操作

2， 使用乐观锁进行控制。乐观锁机制避免了长事务中的数据库加锁开销，大大提升了大并发量下的系统性能。

------

**排查和避免**

1， 查询死锁日志

通过**show engine innodb status\G**命令查看近期死锁日志信息。

2， 使用explain查看下SQL执行计划

3， 查看锁状态变量，通过**show status like’innodb_row_lock%**‘命令检查状态变量，分析系统中的行锁的争夺
情况

- Innodb_row_lock_current_waits：当前正在等待锁的数量

- Innodb_row_lock_time：从系统启动到现在锁定总时间长度
- Innodb_row_lock_time_avg： 每次等待锁的平均时间
- Innodb_row_lock_time_max：从系统启动到现在等待最长的一次锁的时间
- Innodb_row_lock_waits：系统启动后到现在总共等待的次数

> 如果等待次数高，而且每次等待时间长，需要分析系统中为什么会有如此多的等待，然后着手定制优化。

[分析死锁问题](https://www.cnblogs.com/qdhxhz/p/15735876.html)
