# [索引的数据结构](https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html)

## 遍历

页内查找数据：二分查找槽，再遍历具体的数字

B+树查找数据

[具体详情](https://xiaolincoding.com/mysql/index/page.html)

**普通索引和唯一索引**

<img src="https://gitee.com/JieMingLi/document-pics/raw/master/1ed9536031d6698570ea175a7b7f9a46.png" alt="img" style="zoom:67%;" />

```sql
select id from T where k=5
```

普通索引：通过 B+ 树从树根开始，按层搜索到叶子节点，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。

唯一索引：由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

*性能差距*

**查找**

微乎其微，很小，主要在差在以下2个地方。

- 普通索引来说，要多做的那一次查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。
- 如果 记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页。

InnoDB 的数据是按数据页为单位来读写的。当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB。

对于整型字段，一个数据页可以放近千个 key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的 CPU 来说可以忽略不计。

**写数据**

如果插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的。

这个记录要更新的目标页**在内存中**。这时，InnoDB 的处理流程如下：

- 对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；
- 对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。

这个记录要更新的目标页不在内存中。这时，InnoDB 的处理流程如下：

- 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值（写入内存页，读出来的页变为脏页，写redo log 等后续刷新），语句执行结束；
- 对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。（不需要读取磁盘）

将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。所以对于普通索引的写入比唯一索引的写入性能要更高。

[参考](https://time.geekbang.org/column/article/70848)



## 其他数据结构

二叉树-二分查找树-AVL（红黑树，相对高度不可以超过1，会自动平衡，可能会涉及到树相关的旋转）

## B+树的优点

- 非叶子结点保存的是其他节点的指针，所以树的高度会更加矮胖，从而可以减少磁盘的IO
- 插入和删除的效率，因为有冗余的数据，删除不会导致B+树的复杂变化，插入节点可能会导致节点的分裂，但影响的范围较小，不会有旋转相关操作。
- 对于大量范围查找，叶子结点已经排好序，范围查找无须频繁从根节点查找，B树的值都在节点中，所以只能通过需要中序遍历完成范围查找，比如倒序排序，顺序排序（还得说出B树具体的劣势)

# 聚簇索引和辅助索引

聚簇索引和非聚簇索引、主键索引和辅助索引

**聚簇索引（聚集索引）**
1， 聚簇索引是一种数据存储方式，InnoDB的聚簇索引就是按照主键顺序构建 B+Tree结构。B+Tree 的叶子节点
就是行记录，行记录和主键值紧凑地存储在一起。

2， 这也意味着 InnoDB 的主键索引就是数据表本身，它按主键顺序存放了整张表的数据，占用的空间就是整个表数据量的大小。通常说的主键索引就是聚集索引。

InnoDB的表要求**必须**要有聚簇索引：

- 如果表定义了主键，则主键索引就是聚簇索引
- 如果表没有定义主键，则第一个非空unique列作为聚簇索引
- 否则InnoDB会从建一个隐藏的row-id作为聚簇索引

**辅助索引**

InnoDB辅助索引，也叫作二级索引，是根据索引列构建 B+Tree结构。但在B+Tree 的叶子节点中只存了**索引列和主键**的信息。二级索引占用的空间会比聚簇索引小很多，通常创建辅助索引/就是为了提升查询效率。一个表innoDB只能创建一个聚簇索引，但可以创建多个辅助索引。

![image.png](https://gitee.com/JieMingLi/document-pics/raw/master/bVcQNX0.png)



>  聚集索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚集索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。因为实际的数据只能有一个，所以聚簇索引只能有一个，二级索引可以有多个。

# 优化

## 排序优化

explain sql语句，如果用到排序语句（order）的话，extra会有 filesort或者index

filesort：把数据加载到内存中排序，或者在磁盘排序，数据量较大的情况喜爱，需要比较多的IO操作。

- 双路排序
- 单路排序，数据量大的情况可能会演变为多路排序，从而有较多的磁盘io，从而导致查询速率变慢。

index：根据之前B+树的有序性，直接返回有序的列表，IO操作对比filesort少，所以查询的速率会更快



## 查询优化

**慢查询**

查看 MySQL数据库是否开启了慢查询日志和慢查询日志文件的存储位置的命令如下：
`SHOW VARIABLES LIKE 's1ow_query_1og%’`

通过如下命令开启慢查询日志：

```sql
SET global slow_query_1og = ON;
SET g1obal s1ow_query_1og_file='OAK-s1ow.1og’；
SET global 1og_queries_not_using_indexes=ON:
SET 1ong_query_time = 10；
```



long_query_time：指定慢查询的调值，单位秒。如果SQL执行时间超过阀值，就属于慢查询记录到日志
文件中。
log_queries not_using_indexes：表示会记录**没有使用索引**的查询SQL。前提是`slow_query.log`的值为
**ON**，否则不会奏效。

> 可以直接使用文本查看慢查询日志或者三方软件查看

**如何判断是否为慢查询？**
主要依据SQL语句的执行时间，它把当前语句的执行时间跟long_query.time 参数做比较，如果语句的执行时间＞long_query_time，就会把这条执行语句记录到慢直询日志里面。ong_query.time 参数的默认值是 10s，该参数值可以根据自己的业务需要进行调整。

**如何判断是否为慢查询？**
MySQL判断一条语句是否为慢查询语句，主要依据SQL语句的执行时间，它把当前语句的执行时间跟
long_query.time 参数做比较，如果语句的执行时间＞long_query_time，就会把这条执行语句记录到慢
直询日志里面。ong_query.time 参数的默认值是 10s，该参数值可以根据自己的业务需要进行调整。

**慢查询主要的原因**

全表扫描：explain分析出来的type属性all
全索引扫描：explain分析出来的type属性index
索引<u>过滤性</u>不好：靠索引字段选型、数据量和状态、表设计
频繁的回表查询开销：尽量少用select *，使用覆盖索引

**使用索引不一定比不使用索引快**

```sql
select * from user where id > 0
```

虽然使用了索引，但是还是从主键索引1的最左边的叶节点开始向右扫描整个索引1树，进行了**全表扫描**，此
时索引就失去了意义。而像 select * from user where id= 2;这样的语句，才是平时说的使用了索引。它表示的意思是，使用了索引的快速搜索功能，并且有效地减少了扫描行数。

**总结**

在使用索引的时候，不要只关注是否起作用，应该关心索引是否减少了查询扫描的数据行数，如果扫描行数减
少了，效率才会得到提升。对于一个大表，不止要创建索引，还要考虑索引**过滤性**，过滤性好，执行速度才会
快。

**如何提高查询过滤性？**（个人见解，仅供参考）

1， 尽可能少用like，使用**等值**

2， 尽可能使用索引，若多个字段查询，使用联合索引。

3， 在MySQL5.7之后，添加虚拟列进行索引优化 



**分页查询优化**

如果偏移量固定，返回记录量对执行时间有什么影响？

```sql
select* from user 1imit 10000,1；
select* from user 1imit 10000, 10；
select* from user 1imit 10000,100;
select * from user 1imit 10000,1000;
select * from user 1imit 10000,10000；
```

结果：在查询记录量时，低于100条，查询时间基本没有变化，差距不大。随着查询记录量越大，所花费的时



如果查询偏移量变化，返回记录数固定对执行时间有什么影响？

```sql
select * from user 1imit 1,100;
select * from user 1imit 10,100；
select * from user 1imit 100,100;
select * from user 1imit 1000, 100；
select * from user 1imit 10000, 100;
```

结果：在查询记录时，如果查询记录量相同，偏移量超过100后就开始随着偏移量增大，查询时间急剧的增
加。（这种分页查询机制，每次都会从数据库第一条记录开始扫描，越往后查询越慢，而且查询的数据越多，
也会拖慢总直询速度。）

**优化方案**

1， 使用覆盖索引

```sql
select id from user limit 10000, 100;
```

2，利用自查询优化

```sql
select * from user limit 10000,100;
select * from user where id >= (select id from limit 10000, 1) limit 10000,100;
```

原因：使用了id做主键比较(id>=)，并且子查询使用了蛋盖索引进行优化。



# [索引失效](https://xiaolincoding.com/mysql/index/index_lose.html)

失效主要有以下几种场景

1，当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效。不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。

2，对索引使用函数，索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。

3，对索引使用表达式，对索引使用函数差不多

4，如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，执行计划的结果发现这条语句会走全表扫描。 **MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**。所以如果索引字段类型是字符串，查询条件的入参是整形，会把字符串的类型转位整形，再进行比较

5， 联合索引没有使用最左匹配（mysql 5.6之后使用到了[索引下推](https://zhuanlan.zhihu.com/p/121084592)）

6， 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。 



# [Count相关问题](https://xiaolincoding.com/mysql/index/count.html)

count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是**统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个**。

性能：Count(*) == Count(1) >   Count(主键值)  > Count(字段名)

对于Count(主键值) 来说

- 如果只有聚簇索引，nnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。
- 如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。

> 原因：因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引

对于Count(*) = Count(0) = Count(1)来说

INNODB **不会读取记录中的任何字段的值**，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。

> *InnoDB handles SELECT COUNT(`\*`) and SELECT COUNT(`1`) operations in the same way. There is no performance difference.*
