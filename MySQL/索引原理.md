# 聚簇索引和辅助索引

聚簇索引和非聚簇索引、主键索引和辅助索引

**聚簇索引（聚集索引）**
1， 聚簇索引是一种数据存储方式，InnoDB的聚簇索引就是按照主键顺序构建 B+Tree结构。B+Tree 的叶子节点
就是行记录，行记录和主键值紧凑地存储在一起。

2， 这也意味着 InnoDB 的主键索引就是数据表本身，它按主键顺序存放了整张表的数据，占用的空间就是整个表数据量的大小。通常说的主键索引就是聚集索引。

InnoDB的表要求**必须**要有聚簇索引：

- 如果表定义了主键，则主键索引就是聚簇索引
- 如果表没有定义主键，则第一个非空unique列作为聚簇索引
- 否则InnoDB会从建一个隐藏的row-id作为聚簇索引

**辅助索引**

InnoDB辅助索引，也叫作二级索引，是根据索引列构建 B+Tree结构。但在B+Tree 的叶子节点中只存了**索引列和主键**的信息。二级索引占用的空间会比聚簇索引小很多，通常创建辅助索引/就是为了提升查询效率。一个表innoDB只能创建一个聚簇索引，但可以创建多个辅助索引。

![image.png](https://segmentfault.com/img/bVcQNX0)

# 优化

## 排序优化

explain sql语句，如果用到排序语句（order）的话，extra会有 filesort或者index

filesort：把数据加载到内存中排序，或者在磁盘排序，数据量较大的情况喜爱，需要比较多的IO操作。

- 双路排序
- 单路排序，数据量大的情况可能会演变为多路排序，从而有较多的磁盘io，从而导致查询速率变慢。

index：根据之前B+树的有序性，直接返回有序的列表，IO操作对比filesort少，所以查询的速率会更快



## 查询优化

**慢查询**

查看 MySQL数据库是否开启了慢查询日志和慢查询日志文件的存储位置的命令如下：
`SHOW VARIABLES LIKE 's1ow_query_1og%’`

通过如下命令开启慢查询日志：

```sql
SET global slow_query_1og = ON;
SET g1obal s1ow_query_1og_file='OAK-s1ow.1og’；
SET global 1og_queries_not_using_indexes=ON:
SET 1ong_query_time = 10；
```



long_query_time：指定慢查询的调值，单位秒。如果SQL执行时间超过阀值，就属于慢查询记录到日志
文件中。
log_queries not_using_indexes：表示会记录**没有使用索引**的查询SQL。前提是`slow_query.log`的值为
**ON**，否则不会奏效。

> 可以直接使用文本查看慢查询日志或者三方软件查看

**如何判断是否为慢查询？**
主要依据SQL语句的执行时间，它把当前语句的执行时间跟long_query.time 参数做比较，如果语句的执行时间＞long_query_time，就会把这条执行语句记录到慢直询日志里面。ong_query.time 参数的默认值是 10s，该参数值可以根据自己的业务需要进行调整。

**如何判断是否为慢查询？**
MySQL判断一条语句是否为慢查询语句，主要依据SQL语句的执行时间，它把当前语句的执行时间跟
long_query.time 参数做比较，如果语句的执行时间＞long_query_time，就会把这条执行语句记录到慢
直询日志里面。ong_query.time 参数的默认值是 10s，该参数值可以根据自己的业务需要进行调整。

**慢查询主要的原因**

全表扫描：explain分析出来的type属性all
全索引扫描：explain分析出来的type属性index
索引<u>过滤性</u>不好：靠索引字段选型、数据量和状态、表设计
频繁的回表查询开销：尽量少用select *，使用覆盖索引

**使用索引不一定比不使用索引快**

```sql
select * from user where id > 0
```

虽然使用了索引，但是还是从主键索引1的最左边的叶节点开始向右扫描整个索引1树，进行了**全表扫描**，此
时索引就失去了意义。而像 select * from user where id= 2;这样的语句，才是平时说的使用了索引。它表示的意思是，使用了索引的快速搜索功能，并且有效地减少了扫描行数。

**总结**

在使用索引的时候，不要只关注是否起作用，应该关心索引是否减少了查询扫描的数据行数，如果扫描行数减
少了，效率才会得到提升。对于一个大表，不止要创建索引，还要考虑索引**过滤性**，过滤性好，执行速度才会
快。

**如何提高查询过滤性？**（个人见解，仅供参考）

1， 尽可能少用like，使用**等值**

2， 尽可能使用索引，若多个字段查询，使用联合索引。

3， 在MySQL5.7之后，添加虚拟列进行索引优化 



**分页查询优化**

如果偏移量固定，返回记录量对执行时间有什么影响？

```sql
select* from user 1imit 10000,1；
select* from user 1imit 10000, 10；
select* from user 1imit 10000,100;
select * from user 1imit 10000,1000;
select * from user 1imit 10000,10000；
```

结果：在查询记录量时，低于100条，查询时间基本没有变化，差距不大。随着查询记录量越大，所花费的时



如果查询偏移量变化，返回记录数固定对执行时间有什么影响？

```sql
select * from user 1imit 1,100;
select * from user 1imit 10,100；
select * from user 1imit 100,100;
select * from user 1imit 1000, 100；
select * from user 1imit 10000, 100;
```

结果：在查询记录时，如果查询记录量相同，偏移量超过100后就开始随着偏移量增大，查询时间急剧的增
加。（这种分页查询机制，每次都会从数据库第一条记录开始扫描，越往后查询越慢，而且查询的数据越多，
也会拖慢总直询速度。）

**优化方案**

1， 使用覆盖索引

```sql
select id from user limit 10000, 100;
```

2，利用自查询优化

```sql
select * from user limit 10000,100;
select * from user where id >= (select id from limit 10000, 1) limit 10000,100;
```

原因：使用了id做主键比较(id>=)，并且子查询使用了蛋盖索引进行优化。





